import csv
import os
import sys
import re
import argparse

from dst_characterize import identify_party as idtpt
from party_analysis import visualization_parties as vis
from protocol_analysis import protocol_analysis as ptals
from protocol_analysis import visualization_protocols as vis_pro

software_location = "/Users/zhangshu/PycharmWorkspace/intl-iot-new-version-intest"
current_location = "/Users/zhangshu/PycharmProjects/neu_mon-iot-_network_traffic_analysis"
protocol_encrypted_dict = {"1": "encrypted", "0": "unencrypted", "-1": "unknown"}
protocol_details = {"TCP port: 443": "Https", "TCP port: 80": "Http", "UDP port: 80": "Http"}

path = sys.argv[0]
script_dir = os.path.dirname(path)
if script_dir == "":
    script_dir = "."

RED = "\033[31;1m"
END = "\033[0m"

usage_stm = """
Usage: python3 {prog_name} -i PCAP_DIR -m MAC_ADDR {{-v IN_CSV | -s IMC_DIR}} [OPTION]...

Performs destination and protocol analysis. Determines the percentage of first,
support, third, local, advertiser, and analytic party traffic. Produces a CSV
file which includes traffic party, organization, and information about encryption.
Several plots are also generated for visualization.

Example: python3 {prog_name} -i echodot_pcaps/ -m 18:74:2e:41:4d:35 -v echodot.csv -f figs/ -c Amazon -d org,sld -p BarHPlot

Example: python3 {prog_name} -r echodot_pcaps/ -m 18:74:2e:41:4d:35 -s ../intl-iot/ -c Amazon -n 4

Required arguments:
  -i PCAP_DIR path to the directory containing input pcap files for analysis
  -m MAC_ADDR MAC address of the device that generated the data in PCAP_DIR

  AND EITHER

  -v IN_CSV   path to the output CSV of running destination analysis of the
                IMC'19 code on the pcap files in PCAP_DIR

  OR

  -s IMC_DIR  path to the directory containing the code accompanying the paper
                titled "Information Exposure From Consumer IoT Devices: A
                Multidimensional, Network-Informed Measurement Approach" in
                proceedings of the ACM Internet Measurement Conference 2019 (IMC
                2019); the code can be found here: https://github.com/NEU-SNS/intl-iot

Optional arguments:
  -c DEV_MFR  company that created the device that generated the data in PCAP_DIR;
                used to identify first parties (Default = unknown)
  -f FIG_DIR  path to a directory to place the generated plots; will be generated
                if it does not currently exist (Default = plots/)
  -o OUT_CSV  path to the output CSV file; if it exists, results will be appended,
                else, it will be created (Default = results.csv)
  -d DST_TYPS comma-separated list of destination types to use to generate party
                analysis plots; choose from fqdn, org, and sld
  -p PLT_TYPS comma-separated list of plot types to use to generate party analysis
                plots; choose from BarHPlot and PiePlot
  -l          generates plots using DST_TYPS and PLT_TYPS linearly instead of using
                a 2D-array-like style
  -t DPI      dots per inch (DPI0 of a plot) (Default = 72)
  -n NUM_PROC number of CPU processes to use to run the destination analysis and
                protocol analysis portions (Default = 1)
  -h          print this usage statement and exit

Notes:
 - Either the -v option or the -s option must be specified. Use the -v option if you
     already have the output CSV generated by the IMC'19 code.
 - Types must be specified in both the -d and -p options for party analysis plots to
     be generated. DST_TYPS is the type of data used to make the plot, while PLT_TYPS
     is the type of graph used to display the data.
 - Example for the -l option: If DST_TYPS is fqdn,org and PLT_TYPS is BarHPlot,PiePlot,
     the following sets of plots would be generated
       - without the -l option: BarHPlot using fqdn, BarHPlot using org, PiePlot using
           fqdn, PiePlot using org.
       - with the -l option: BarHPlot using fqdn, PiePlot using org.
 - If the -l option is specified and DST_TYPS and PLT_TYPS are of different lengths,
     plots will be generated up until there are no more items in a list.

For more information, see the README.""".format(prog_name=path)


# isError is either 0 or 1
def print_usage(isError):
    if isError:
        print(usage_stm, file=sys.stderr)
    else:
        print(usage_stm)
    exit(isError)


def not_valid_dir(direc, dir_print):
    errors = False
    if not os.path.isdir(direc):
        errors = True
        print("%s%s: Error: The %s directory \"%s\" is not a directory.%s"
              % (RED, path, dir_print, direc, END), file=sys.stderr)
    else:
        if not os.access(direc, os.R_OK):
            errors = True
            print("%s%s: Error: The \"%s\" directory does not have read permission.%s"
                  % (RED, path, direc, END), file=sys.stderr)
        if not os.access(direc, os.X_OK):
            errors = True
            print("%s%s: Error: The \"%s\" directory does not have execute permission.%s"
                  % (RED, path, direc, END), file=sys.stderr)

    return errors


if __name__ == "__main__":
    print("Running %s..." % path)

    # Options
    parser = argparse.ArgumentParser(usage=usage_stm, add_help=False)
    parser.add_argument("-i", dest="dir_name", default="")
    parser.add_argument("-m", dest="mac", default="")
    parser.add_argument("-v", dest="in_csv", default="")
    parser.add_argument("-s", dest="software_location", default="")
    parser.add_argument("-c", dest="company", default="unknown")
    parser.add_argument("-f", dest="fig_dir", default="plots")
    parser.add_argument("-o", dest="out_csv", default="results.csv")
    parser.add_argument("-d", dest="dst_types", default="")
    parser.add_argument("-p", dest="plot_types", default="")
    parser.add_argument("-l", dest="linear", action="store_true", default=False)
    parser.add_argument("-t", dest="dpi", default="72")
    parser.add_argument("-n", dest="num_proc", default="1")
    parser.add_argument("-h", dest="help", action="store_true", default=False)
    args = parser.parse_args()

    if args.help:
        print_usage(0)

    dir_name = args.dir_name
    mac = args.mac
    software_location = args.software_location
    company: str = args.company
    company = company.lower()
    dst_types = args.dst_types.split(",")
    # for each type, make lowercase, remove trailing/leading white space
    dst_types = [dst_type.strip().lower() for dst_type in dst_types]
    plot_types = args.plot_types.split(",")
    plot_types = [plot_type.strip().lower() for plot_type in plot_types]
    if not args.linear:  # remove duplicates if not generating plots linearly
        dst_types = list(dict.fromkeys(dst_types))
        plot_types = list(dict.fromkeys(plot_types))

    # Error checking arguments
    errors = False
    if dir_name == "":
        errors = True
        print("%s%s: Error: Input pcap directory (-i) required.%s"
              % (RED, path, END), file=sys.stderr)
    elif not_valid_dir(dir_name, "input pcap"):
        errors = True

    if mac == "":
        errors = True
        print("%s%s: Error: MAC address (-m) required.%s" % (RED, path, END), file=sys.stderr)
    elif not re.match("([0-9a-f]{2}[:]){5}[0-9a-f]{2}$", mac):
        errors = True
        print("%s%s: Error: Invalid MAC address \"%s\". Valid format: xx:xx:xx:xx:xx:xx%s"
              % (RED, path, mac, END), file=sys.stderr)

    if args.in_csv == "" and software_location == "":
        errors = True
        print("%s%s: Error: Either the -v argument or the -s argument is need.%s"
              % (RED, path, END), file=sys.stderr)
    elif args.in_csv != "":
        if not args.in_csv.endswith(".csv"):
            errors = True
            print("%s%s: Error: Input file is not a CSV (.csv) file. Received %s.%s"
                  % (RED, path, args.in_csv, END), file=sys.stderr)
        elif not os.path.isfile(args.in_csv):
            errors = True
            print("%s%s: Error: The input CSV \"%s\" does not exist.%s"
                  % (RED, path, args.in_csv, END), file=sys.stderr)
    else:
        if software_location == "":
            errors = True
            print("%s%s: Error: IMC19 directory (-s) required.%s"
                  % (RED, path, END), file=sys.stderr)
        else:
            software_location += "/destination/analyze.py"
            if not_valid_dir(os.path.dirname(os.path.dirname(software_location)), "IMC'19"):
                errors = True
            elif not_valid_dir(os.path.dirname(software_location), "destination analysis"):
                errors = True
            else:
                if not os.path.isfile(software_location):
                    errors = True
                    print("%s%s: Error: The script \"%s\" is missing.%s"
                          % (RED, path, software_location, END), file=sys.stderr)
                elif not os.access(software_location, os.R_OK):
                    errors = True
                    print("%s%s: Error: The script \"%s\" does not have read permission.%s"
                          % (RED, path, software_location, END), file=sys.stderr)

    if not args.out_csv.endswith(".csv"):
        errors = True
        print("%s%s: Error: The output file should be a CSV (.csv) file. Received \"%s\".%s"
              % (RED, path, args.out_csv, END), file=sys.stderr)

    for dst_type in dst_types:
        if dst_type not in ("sld", "fqdn", "org", ""):
            errors = True
            print("%s%s: Error: \"%s\" is not a valid destination type."
                  " Choose from fqdn, org, and sld.%s"
                  % (RED, path, dst_type, END), file=sys.stderr)

    for plot_type in plot_types:
        if plot_type not in ("pieplot", "barhplot", ""):
            errors = True
            print("%s%s: Error: \"%s\" is not a valid plot type."
                  " Choose from BarHPlot and PiePlot.%s"
                  % (RED, path, plot_type, END), file=sys.stderr)

    bad_proc = False
    try:
        if int(args.num_proc) > 0:
            num_proc = int(args.num_proc)
        else:
            bad_proc = True
    except:
        bad_proc = True

    if bad_proc:
        errors = True
        print("%s%s: Error: The number of processes must be a positive integer. Received \"%s\".%s"
              % (RED, path, args.num_proc, END), file=sys.stderr)

    bad_dpi = False
    try:
        if int(args.dpi) > 0:
            dpi = int(args.dpi)
        else:
            bad_dpi = True
    except:
        bad_dpi = True

    if bad_dpi:
        errors = True
        print("%s%s: Error: The DPI must be a positive integer. Received \"%s\".%s"
              % (RED, path, args.dpi, END), file=sys.stderr)

    if errors:
        print_usage(1)
    # End error checking

    # Run destination analysis if necessary
    in_csv = args.in_csv
    if in_csv == "":
        in_csv = args.fig_dir + "/" + company + "_tmp.csv"
        print("Running destination analysis...\n  python3 %s -i %s -m %s -n %s -o %s"
              % (software_location, dir_name, mac, num_proc, in_csv))
        os.system("python3 %s -i %s -m %s -n %s -o %s > /dev/null"
                  % (software_location, dir_name, mac, num_proc, in_csv))

    # characterize the parties
    print("Characterizing the parties...")
    result = idtpt.run_extract_third_parties(in_csv, script_dir, company)

    # check if the traffic is encrypted
    print("Analyzing traffic encryption...")

    # result is a list of DestinationPro that
    # contains all the info
    result = ptals.run(dir_name=dir_name,
                       device_mac=mac,
                       script_dir=script_dir,
                       previous_info=result,
                       num_proc=num_proc)

    out_csv = args.out_csv
    # write the result to a csv file
    out_csv_dir = os.path.dirname(out_csv)
    if out_csv_dir != "" and not os.path.isdir(out_csv_dir):
        os.system("mkdir -pv " + out_csv_dir)

    with open(file=out_csv, mode='w') as result_csv_file:
        fieldnames = ('ip', 'host', 'host_full', 'traffic_snd',
                      'traffic_rcv', 'packet_snd', 'packet_rcv', 'country',
                      'party', 'organization', 'protocol&port', 'encryption')
        writer = csv.DictWriter(result_csv_file, fieldnames=fieldnames)
        writer.writeheader()
        for dp in result:
            dst = dp.host
            pro = dp.protocol_port
            send = dp.snd
            received = dp.rcv
            p_snd = dp.p_snd
            p_rcv = dp.p_rcv
            encrypted = protocol_encrypted_dict[pro.encrypted]
            protocol_p = pro.protocol_port
            if protocol_p in protocol_details:
                protocol_p = protocol_details[protocol_p]
            writer.writerow({'ip': dst.ip,
                             'host': dst.host,
                             'host_full': dst.host_full,
                             'traffic_snd': send,
                             'traffic_rcv': received,
                             'packet_snd': p_snd,
                             'packet_rcv': p_rcv,
                             'country': dst.country,
                             'party': dst.party,
                             'organization': dst.organization,
                             'protocol&port': protocol_p,
                             'encryption': encrypted})

    print("Results written to \"" + out_csv + "\"")

    # analyze the percentage of each party in all hosts and the amount of traffic
    # sent to each party, and generate the plots
    if dst_types != [""] and plot_types != [""]:
        print("Calculating party percentages and generating plots...")
        vis.calc_party_pct(csv_filename=out_csv, company=company, fig_dir=args.fig_dir,
                           fig_dpi=dpi, dst_types=dst_types, plot_types=plot_types,
                           linear=args.linear)

        # analyze the protocol and ports use; calculate the amount of traffic sent to
        # each destination and protocols, and visualizing the results as plots
        print("Calculating protocol percentages for encryption analysis and generating plots...")
        vis_pro.calc_encrypted_dst_pct(previous_data=result, company=company,
                                       fig_dir=args.fig_dir, fig_dpi=dpi, dst_types=dst_types,
                                       plot_types=plot_types, linear=args.linear)

    print("Analysis finished.")
